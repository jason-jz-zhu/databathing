"""
Test suite for COEngine (Capital One Banking Engine)
Tests banking-specific functionality, compliance features, and security enhancements
"""

import unittest
from databathing.engines.co_engine import COEngine
from databathing import Pipeline


class TestCOEngine(unittest.TestCase):
    """Test cases for COEngine functionality"""
    
    def test_basic_select_with_security_config(self):
        """Test basic SELECT with security configuration"""
        query = "SELECT customer_id, account_number, ssn FROM customers WHERE active = 1"
        
        security_config = {
            'enable_masking': True,
            'enable_audit': True
        }
        
        pipeline = Pipeline(query, engine="co", security_config=security_config)
        result = pipeline.parse()
        
        # Should contain audit trail and masking comments
        self.assertIn("# Generated by Capital One DataBathing Engine", result)
        self.assertIn("# COMPLIANCE: Sensitive columns detected:", result)
        self.assertIn("co_secure_df =", result)
        
    def test_sensitive_column_detection(self):
        """Test detection of sensitive columns"""
        query = "SELECT customer_id, ssn, email, phone FROM customer_data"
        
        security_config = {'enable_masking': False, 'enable_audit': True}
        pipeline = Pipeline(query, engine="co", security_config=security_config)
        result = pipeline.parse()
        
        # Should detect sensitive columns
        self.assertIn("ssn", result.lower())
        self.assertIn("email", result.lower())
        
    def test_customer_transaction_query(self):
        """Test customer transaction analysis query"""
        query = """
        SELECT 
            c.customer_id,
            c.first_name,
            count(t.transaction_id) as transaction_count,
            sum(t.amount) as total_amount
        FROM customers c
        JOIN transactions t ON c.customer_id = t.customer_id
        WHERE t.transaction_date >= '2023-01-01'
        GROUP BY c.customer_id, c.first_name
        """
        
        security_config = {'enable_audit': True}
        pipeline = Pipeline(query, engine="co", security_config=security_config)
        result = pipeline.parse()
        
        # Should include audit trail for transaction data
        self.assertIn("# COMPLIANCE: Audit trail enabled", result)
        self.assertIn("co_secure_df =", result)
        
    def test_compliance_report_generation(self):
        """Test compliance report generation"""
        query = "SELECT customer_id, ssn, account_number FROM sensitive_customer_data"
        
        # Create COEngine instance directly to test compliance report
        from mo_sql_parsing import parse_bigquery as parse
        import json
        
        parsed_query = parse(query)
        parsed_json = json.loads(json.dumps(parsed_query, indent=4))
        
        security_config = {'enable_masking': True, 'enable_audit': True}
        engine = COEngine(parsed_json, security_config)
        result = engine.parse()
        
        # Get compliance report
        compliance_report = engine.get_compliance_report()
        
        self.assertIn('sensitive_columns_detected', compliance_report)
        self.assertIn('audit_trail_required', compliance_report)
        self.assertIn('compliance_score', compliance_report)
        self.assertTrue(compliance_report['audit_trail_required'])
        
    def test_financial_aggregations(self):
        """Test banking-specific aggregation functions"""
        query = """
        SELECT 
            customer_id,
            sum(balance) as total_balance,
            avg(balance) as avg_balance,
            stddev(balance) as balance_volatility,
            percentile_approx(balance, 0.5) as median_balance
        FROM account_balances
        GROUP BY customer_id
        """
        
        pipeline = Pipeline(query, engine="co")
        result = pipeline.parse()
        
        # Should handle banking-specific functions
        self.assertIn("stddev", result)
        self.assertIn("percentile_approx", result)
        self.assertIn("co_secure_df =", result)
        
    def test_join_with_sensitive_data(self):
        """Test JOIN operations with sensitive data detection"""
        query = """
        SELECT 
            c.customer_id,
            c.first_name,
            a.account_number,
            a.balance
        FROM customers c
        JOIN accounts a ON c.customer_id = a.customer_id
        WHERE a.account_type = 'CHECKING'
        """
        
        security_config = {'enable_masking': True}
        pipeline = Pipeline(query, engine="co", security_config=security_config)
        result = pipeline.parse()
        
        # Should detect account_number as sensitive
        self.assertIn("Generated by Capital One DataBathing Engine", result)
        
    def test_union_operations(self):
        """Test UNION operations with CO engine"""
        query = """
        SELECT customer_id, balance FROM checking_accounts
        UNION ALL
        SELECT customer_id, balance FROM savings_accounts
        """
        
        pipeline = Pipeline(query, engine="co")
        result = pipeline.parse()
        
        self.assertIn("union", result.lower())
        self.assertIn("co_secure_df =", result)
        
    def test_with_statement_cte(self):
        """Test WITH statement (CTE) support"""
        query = """
        WITH customer_summary AS (
            SELECT 
                customer_id,
                sum(balance) as total_balance
            FROM accounts
            GROUP BY customer_id
        )
        SELECT 
            customer_id,
            total_balance,
            case when total_balance > 100000 then 'HIGH_VALUE' else 'STANDARD' end as customer_tier
        FROM customer_summary
        """
        
        pipeline = Pipeline(query, engine="co")
        result = pipeline.parse()
        
        self.assertIn("customer_summary =", result)
        self.assertIn("co_secure_df =", result)
        
    def test_order_by_and_limit(self):
        """Test ORDER BY and LIMIT functionality"""
        query = """
        SELECT 
            customer_id,
            balance,
            last_transaction_date
        FROM customer_accounts
        ORDER BY balance DESC, last_transaction_date DESC
        LIMIT 100
        """
        
        pipeline = Pipeline(query, engine="co")
        result = pipeline.parse()
        
        self.assertIn("orderBy", result)
        self.assertIn("limit", result)
        self.assertIn("desc()", result)
        
    def test_where_clause_with_sensitive_patterns(self):
        """Test WHERE clause handling with potential sensitive data patterns"""
        query = """
        SELECT customer_id, first_name
        FROM customers 
        WHERE email LIKE '%@company.com' 
          AND phone IS NOT NULL
        """
        
        security_config = {'enable_audit': True}
        pipeline = Pipeline(query, engine="co", security_config=security_config)
        result = pipeline.parse()
        
        # Should trigger audit trail due to email/phone references
        self.assertIn("Generated by Capital One DataBathing Engine", result)


class TestCOEngineCompliance(unittest.TestCase):
    """Test compliance features of COEngine"""
    
    def test_pci_compliance_detection(self):
        """Test PCI compliance validation"""
        from databathing.validation.co_compliance_rules import validate_banking_compliance
        
        # Code with potential PCI violations
        test_code = """
        customers.filter("cc_number = '4111-1111-1111-1111'")
        .selectExpr("customer_id", "full_card_number", "cvv")
        """
        
        compliance_result = validate_banking_compliance(test_code, "co")
        
        self.assertGreater(compliance_result['critical_issues'], 0)
        self.assertLess(compliance_result['overall_compliance_score'], 90)
        
    def test_pii_detection(self):
        """Test PII data detection"""
        from databathing.validation.co_compliance_rules import validate_banking_compliance
        
        test_code = """
        customers.selectExpr("ssn", "email", "phone")
        .filter("ssn = '123-45-6789'")
        """
        
        compliance_result = validate_banking_compliance(test_code, "co")
        
        self.assertGreater(len(compliance_result['issues']), 0)
        # Should detect PII issues
        pii_issues = [issue for issue in compliance_result['issues'] 
                     if 'pii' in issue.rule.lower() or 'ssn' in issue.message.lower()]
        self.assertGreater(len(pii_issues), 0)
        
    def test_audit_requirements(self):
        """Test audit trail requirements for financial data"""
        from databathing.validation.co_compliance_rules import validate_banking_compliance
        
        test_code = """
        transactions.join(accounts, transactions.account_id == accounts.account_id)
        .selectExpr("transaction_id", "amount", "transaction_date")
        """
        
        compliance_result = validate_banking_compliance(test_code, "co")
        
        # Should have warnings about missing audit trail
        audit_issues = [issue for issue in compliance_result['issues'] 
                       if 'audit' in issue.message.lower()]
        self.assertGreaterEqual(len(audit_issues), 0)  # May or may not trigger depending on specific rules


class TestCOEngineIntegration(unittest.TestCase):
    """Integration tests for COEngine with Pipeline"""
    
    def test_pipeline_with_co_engine(self):
        """Test Pipeline integration with CO engine"""
        query = "SELECT customer_id, account_balance FROM accounts WHERE active = true"
        
        pipeline = Pipeline(query, engine="co", validate=False)  # Skip validation for this test
        result = pipeline.parse()
        
        self.assertIsInstance(result, str)
        self.assertIn("co_secure_df =", result)
        
    def test_complex_banking_query(self):
        """Test complex banking query with multiple features"""
        query = """
        WITH high_value_customers AS (
            SELECT 
                customer_id,
                sum(balance) as total_balance
            FROM accounts
            WHERE account_status = 'ACTIVE'
            GROUP BY customer_id
            HAVING sum(balance) > 50000
        ),
        customer_transactions AS (
            SELECT 
                hvc.customer_id,
                hvc.total_balance,
                count(t.transaction_id) as transaction_count,
                avg(t.amount) as avg_transaction_amount
            FROM high_value_customers hvc
            JOIN transactions t ON hvc.customer_id = t.customer_id
            WHERE t.transaction_date >= date_sub(current_date(), 90)
            GROUP BY hvc.customer_id, hvc.total_balance
        )
        SELECT 
            customer_id,
            total_balance,
            transaction_count,
            avg_transaction_amount,
            case 
                when avg_transaction_amount > 5000 then 'HIGH_ACTIVITY'
                when avg_transaction_amount > 1000 then 'MEDIUM_ACTIVITY'
                else 'LOW_ACTIVITY'
            end as activity_level
        FROM customer_transactions
        ORDER BY total_balance DESC
        LIMIT 50
        """
        
        security_config = {
            'enable_masking': False,
            'enable_audit': True
        }
        
        pipeline = Pipeline(query, engine="co", security_config=security_config, validate=False)
        result = pipeline.parse()
        
        # Should handle CTEs, JOINs, aggregations, CASE statements, ORDER BY, LIMIT
        self.assertIn("high_value_customers =", result)
        self.assertIn("customer_transactions =", result)
        self.assertIn("co_secure_df =", result)
        self.assertIn("Generated by Capital One DataBathing Engine", result)


if __name__ == '__main__':
    unittest.main()