# COEngine - Capital One Banking Engine

## Overview

The COEngine is a specialized SQL-to-PySpark code generator designed specifically for Capital One's banking and financial services requirements. It extends the base DataBathing functionality with banking-specific compliance, security, and domain expertise.

## Key Features

### 🏦 Banking Compliance & Security
- **PCI DSS Compliance**: Automatic detection and handling of credit card data
- **PII Detection**: Identifies and masks personally identifiable information
- **SOX Compliance**: Sarbanes-Oxley compliance for financial reporting
- **GLBA Compliance**: Gramm-Leach-Bliley Act compliance for customer financial information
- **AML Monitoring**: Anti-Money Laundering pattern detection
- **Data Encryption**: Automatic encryption recommendations for sensitive fields

### 🔒 Security Features  
- **Sensitive Data Detection**: Automatically identifies SSN, account numbers, emails, etc.
- **Data Masking**: Built-in masking for sensitive columns (SSN: XXX-XX-1234)
- **Audit Trail**: Automatic audit column generation with timestamps and user tracking
- **Security Comments**: Generated code includes compliance and security annotations

### 📊 Banking Domain Templates
- **Customer 360 Views**: Pre-built templates for comprehensive customer analysis
- **Risk Management**: Credit scoring, portfolio analysis, stress testing scenarios
- **Regulatory Reporting**: Templates for CCAR, CECL, Basel III reporting
- **Fraud Detection**: Pattern templates for fraud identification
- **AML Patterns**: Anti-Money Laundering monitoring templates

### ⚙️ Advanced Features
- **Banking-Specific Functions**: Support for financial aggregations (stddev, percentile_approx, etc.)
- **Compliance Scoring**: Automatic compliance score calculation (0-100)
- **Risk Classification**: Built-in customer and portfolio risk categorization
- **Early Warning System**: Templates for identifying deteriorating credit quality

## Quick Start

### Basic Usage

```python
from databathing import Pipeline

# Basic query with security features
query = """
SELECT 
    customer_id,
    first_name,
    ssn,
    account_number,
    balance
FROM customers c
JOIN accounts a ON c.customer_id = a.customer_id
WHERE a.status = 'ACTIVE'
"""

# Security configuration
security_config = {
    'enable_masking': True,    # Enable data masking
    'enable_audit': True       # Add audit trail columns
}

# Generate banking-compliant PySpark code
pipeline = Pipeline(query, engine="co", security_config=security_config)
result = pipeline.parse()
print(result)
```

### Output Example

```python
# Generated by Capital One DataBathing Engine
# COMPLIANCE: Sensitive columns detected: ssn, account_number, customer_id
# COMPLIANCE: Audit trail enabled for this query
# SECURITY: Data masking enabled

co_secure_df = customers.alias("c")\
.join(accounts.alias("a"), col("c.customer_id")==col("a.customer_id"), "inner")\
.filter("a.status = 'ACTIVE'")\
.selectExpr(
    "'***MASKED***' as customer_id_masked",
    "first_name", 
    "concat('XXX-XX-', substring(ssn, -4, 4)) as ssn_masked",
    "concat('****', substring(account_number, -4, 4)) as account_number_masked",
    "balance",
    "current_timestamp() as co_processing_timestamp",
    "current_user() as co_processed_by",
    "'databathing_co_engine' as co_processing_system"
)
```

## Banking Templates

### Customer 360 Templates

```python
from databathing.templates.customer_360 import Customer360Templates, Customer360Config

# Configure customer data sources
config = Customer360Config(
    customer_table="customers",
    account_table="accounts",
    transaction_table="transactions",
    enable_masking=True,
    include_audit_trail=True
)

# Generate Customer 360 profile query
customer_profile_sql = Customer360Templates.basic_customer_profile(config)

# Convert to PySpark with COEngine
pipeline = Pipeline(customer_profile_sql, engine="co")
pyspark_code = pipeline.parse()
```

### Risk Management Templates

```python
from databathing.templates.risk_management import RiskManagementTemplates, RiskConfig

config = RiskConfig(
    customer_table="customers",
    loan_table="loans", 
    credit_bureau_table="credit_bureau_data",
    enable_stress_testing=True
)

# Generate comprehensive credit risk scoring
risk_sql = RiskManagementTemplates.credit_risk_scoring(config)
pipeline = Pipeline(risk_sql, engine="co")
risk_code = pipeline.parse()
```

## Compliance Validation

### Banking Compliance Rules

```python
from databathing.validation.co_compliance_rules import validate_banking_compliance

# Validate generated code for compliance
code = """
customers.selectExpr("customer_id", "ssn", "credit_card")
.filter("balance > 10000")
"""

compliance_result = validate_banking_compliance(code, "co")

print(f"Compliance Score: {compliance_result['overall_compliance_score']}/100")
print(f"Grade: {compliance_result['compliance_grade']}")
print(f"Critical Issues: {compliance_result['critical_issues']}")

# View specific issues
for issue in compliance_result['issues']:
    print(f"- [{issue.severity}] {issue.message}")
```

## Available Templates

### Customer 360 Templates
- `basic_customer_profile()` - Core customer demographics and account summary
- `customer_transaction_summary()` - Transaction behavior analysis  
- `customer_product_affinity()` - Cross-sell opportunity identification
- `customer_lifecycle_analysis()` - Lifecycle stage and engagement scoring
- `customer_profitability_analysis()` - Revenue and profitability metrics

### Risk Management Templates
- `credit_risk_scoring()` - Comprehensive credit risk assessment
- `portfolio_risk_analysis()` - Portfolio-level risk concentrations
- `stress_testing_scenarios()` - Economic stress testing scenarios
- `early_warning_system()` - Credit quality deterioration detection

## Compliance Rules

### Built-in Compliance Checks
- **PCI DSS**: Credit card data handling validation
- **PII Detection**: Personal information identification and masking
- **SOX Compliance**: Financial reporting audit requirements
- **GLBA**: Customer financial information protection
- **AML**: Transaction monitoring requirements
- **Data Retention**: Historical data access validation
- **Encryption**: Sensitive data encryption requirements

### Custom Compliance Rules

```python
from databathing.validation.custom_rules import add_regex_rule

# Add custom banking compliance rule
add_regex_rule(
    name="high_value_transaction_monitoring",
    pattern=r'amount\s*[>]\s*100000',
    message="High-value transactions require additional monitoring",
    suggestion="Implement enhanced monitoring for transactions over $100K",
    engines=["co"],
    severity="warning"
)
```

## Advanced Configuration

### Security Configuration Options

```python
security_config = {
    'enable_masking': True,           # Enable automatic data masking
    'enable_audit': True,             # Add audit trail columns  
    'mask_customer_id': True,         # Mask customer identifiers
    'mask_account_numbers': True,     # Mask account numbers
    'mask_ssn': True,                 # Mask social security numbers
    'mask_emails': True,              # Mask email addresses
    'encryption_at_rest': True,       # Flag for encryption requirements
    'compliance_level': 'STRICT'      # Compliance strictness level
}

pipeline = Pipeline(query, engine="co", security_config=security_config)
```

### Compliance Report Details

```python
# Get detailed compliance information
from databathing.engines.co_engine import COEngine

engine = COEngine(parsed_query, security_config)
result = engine.parse()

compliance_report = engine.get_compliance_report()
print(compliance_report)
# {
#     'sensitive_columns_detected': ['ssn', 'account_number'],
#     'audit_trail_required': True,
#     'masking_enabled': True, 
#     'audit_enabled': True,
#     'compliance_score': 95
# }
```

## Integration with Capital One Infrastructure

### Deployment Considerations
- **Environment-Specific Configs**: Different settings for Dev/Test/Prod
- **Data Lake Integration**: Optimized for Capital One's data architecture  
- **Kubernetes Deployment**: Generated code includes deployment annotations
- **Cost Optimization**: Automatic resource sizing recommendations
- **Multi-Region Support**: Cross-region data access patterns

### Best Practices
1. **Always Enable Security Features**: Use masking and audit trails in production
2. **Regular Compliance Validation**: Run compliance checks in CI/CD pipelines
3. **Template Usage**: Leverage pre-built templates for consistency
4. **Code Review**: Include compliance scores in code review process
5. **Monitoring**: Implement data quality and security monitoring

## Testing

Run COEngine tests:
```bash
export PYTHONPATH=.
python -m unittest tests.test_co_engine -v
```

## Examples

See `examples/co_engine_demo.py` for comprehensive usage examples including:
- Basic security features demonstration
- Customer 360 template usage  
- Risk management template usage
- Compliance validation examples
- Complex banking query handling

## Support

For questions or issues specific to COEngine:
1. Review this documentation and examples
2. Check test cases in `tests/test_co_engine.py`
3. Examine compliance rules in `databathing/validation/co_compliance_rules.py`
4. Review template implementations in `databathing/templates/`

---

**COEngine** - Banking-compliant SQL-to-PySpark generation for Capital One's financial services needs.